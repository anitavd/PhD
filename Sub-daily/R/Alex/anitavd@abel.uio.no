z.p <- function(p,mu, sigma, xi)
  {
    ##AFL, 31.07.13
    if(abs(xi) < 1e-5)
      {
        return(mu - sigma * log( -log(1 - p)))
      }else{
        return(mu - sigma/xi * (1 - (-log(1 - p))^(-xi)))
      }
  }

GP.C <- function(alpha, lambda, x.1, x.2)
  {
    ##AFL, 31.07.13
    ##returns a gaussian process covariance matrix
    n.1 <- dim(x.1)[1]
    n.2 <- dim(x.2)[1]
    d <- dim(x.1)[2]
    C <- matrix(0, n.1, n.2)
    for(i in 1:n.1)
      {
        for(j in 1:n.2)
          {
            d.ij <- sqrt(sum( (x.1[i,] - x.2[j,])^2))
            C[i,j] <- alpha * exp(-d.ij/lambda)
          }
      }
    return(C)
  }

make.D <- function(x.1, x.2)
  {
    ##AFL, 31.07.13
    ##returns the distance matrix used by a Gaussian Process
    n.1 <- dim(x.1)[1]
    n.2 <- dim(x.2)[1]
    d <- dim(x.1)[2]
    D <- matrix(0, n.1, n.2)
    for(i in 1:n.1)
      {
        for(j in 1:n.2)
          {
            D[i,j] <- sqrt(sum( (x.1[i,] - x.2[j,])^2))
          }
      }
    return(D)
  }

impute.value <- function(mc, coord.new, x.new.loc, x.new.scale, x.new.shape,p.return)
  {
    ## AFL, 31.07.13
    S <- dim(mc$chain.loc)[1]
    D.inner <- make.D(mc$coord, mc$coord)
    D.outer <- make.D(matrix(coord.new,1,2), mc$coord)
    n.sta <- dim(mc$coord)[1]
    loc.new <- rep(0, S)
    scale.new <- rep(0, S)
    shape.new <- rep(0, S)
    p.loc <- dim(mc$loc.dsgn.mat)[2]
    p.scale <- dim(mc$scale.dsgn.mat)[2]
    p.shape <- dim(mc$shape.dsgn.mat)[2]
    Z.p <- rep(0, S)
      
    for(s in 1:S)
      {
##        if(s%%10==0)print(s)
        ##--- First for the loc ------
        beta.mu <- mc$chain.loc[s,1:p.loc]
        mu.hat <- mc$loc.dsgn.mat %*% beta.mu
        resid.hat <- mc$chain.loc[s,(p.loc + 3 + 1):(p.loc + 3 + n.sta)] - mu.hat
        alpha <- mc$chain.loc[s,p.loc + 1]
        lambda <- mc$chain.loc[s,p.loc + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        resid.impute.mean <- C.outer %*% solve(C.inner) %*% resid.hat
        resid.impute.var <- alpha - C.outer %*% solve(C.inner) %*% t(C.outer)
        if(resid.impute.var < 1e-5)
          {
            resid.impute <- resid.impute.mean
          }else{
            resid.impute <- rnorm(1,resid.impute.mean, sd = sqrt(resid.impute.var))
          }
        mu.impute <- x.new.loc %*% beta.mu + resid.impute
        loc.new[s] <- mu.impute
        ##-------------------------------

        ##--- Now the Scale -------------
        beta <- mc$chain.scale[s,1:p.scale]
        sig.hat <- mc$scale.dsgn.mat %*% beta
        resid.hat <- mc$chain.scale[s,(p.scale + 3 + 1):(p.scale + 3 + n.sta)] - sig.hat
        alpha <- mc$chain.scale[s,p.scale + 1]
        lambda <- mc$chain.scale[s,p.scale + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        resid.impute.mean <- C.outer %*% solve(C.inner) %*% resid.hat
        resid.impute.var <- alpha - C.outer %*% solve(C.inner) %*% t(C.outer)
        if(resid.impute.var < 1e-5)
          {
            resid.impute <- resid.impute.mean
          }else{
            resid.impute <- rnorm(1,resid.impute.mean, sd = sqrt(resid.impute.var))
          }
        sig.impute <- x.new.scale %*% beta + resid.impute
        scale.new[s] <- sig.impute
        ##------------------------------------

        ##--- Now the Shape -------------
        beta <- mc$chain.shape[s,1:p.shape]
        hat <- mc$shape.dsgn.mat %*% beta
        resid.hat <- mc$chain.shape[s,(p.shape + 3 + 1):(p.shape + 3 + n.sta)] - hat
        alpha <- mc$chain.shape[s,p.shape + 1]
        lambda <- mc$chain.shape[s,p.shape + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        resid.impute.mean <- C.outer %*% solve(C.inner) %*% resid.hat
        resid.impute.var <- alpha - C.outer %*% solve(C.inner) %*% t(C.outer)
        if(resid.impute.var < 1e-5)
          {
            resid.impute <- resid.impute.mean
          }else{
            resid.impute <- rnorm(1,resid.impute.mean, sd = sqrt(resid.impute.var))
          }
        xi.impute <- x.new.shape %*% beta + resid.impute
        shape.new[s] <- xi.impute
        ##------------------------------------

        ##------ Get the Z.p -----------------
        Z.p[s] <- z.p(p.return, mu.impute,sig.impute,xi.impute)
        ##------------------------------------
      }
    
    return(list(Z = Z.p, shape = shape.new, scale = scale.new, loc = loc.new))

  }
