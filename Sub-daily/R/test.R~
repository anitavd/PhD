z.p <- function(p,mu, sigma, xi)
  {
    ##AFL, 31.07.13
    if(abs(xi[1]) < 1e-5)
      {
        return(mu - sigma * log( -log(1 - p)))
      }else{
        return(mu - sigma/xi * (1 - (-log(1 - p))^(-xi)))
      }
  }

GP.C <- function(alpha, lambda, x.1, x.2)
  {
    ##AFL, 31.07.13
    ##returns a gaussian process covariance matrix
    n.1 <- dim(x.1)[1]
    n.2 <- dim(x.2)[1]
    d <- dim(x.1)[2]
    C <- matrix(0, n.1, n.2)
    for(i in 1:n.1)
      {
        for(j in 1:n.2)
          {
            d.ij <- sqrt(sum( (x.1[i,] - x.2[j,])^2))
            C[i,j] <- alpha * exp(-d.ij/lambda)
          }
      }
    return(C)
  }

##for A a vecor
quad.form <- function(A,B)
  {
    return(A %*% B %*% A)
  }

make.D <- function(x.1, x.2)
  {
    ##AFL, 31.07.13
    ##returns the distance matrix used by a Gaussian Process
    n.1 <- dim(x.1)[1]
    n.2 <- dim(x.2)[1]
    d <- dim(x.1)[2]
    D <- matrix(0, n.1, n.2)
    for(j in 1:n.2)
          {
            D[,j] <- sqrt(colSums( (t(x.1) - x.2[j,])^2))
          }
    return(D)
  }

impute.value <- function(mc, coord.new, x.new.loc, x.new.scale, x.new.shape,p.return)
  {
    ## AFL, 31.07.13
    ## AFL, 3.8.13 updated to take a block

    S <- dim(mc$chain.loc)[1]
    n.sta <- dim(mc$coord)[1]
    n.impute <- dim(coord.new)[1]

    D.inner <- make.D(mc$coord, mc$coord)
    D.outer <- make.D(coord.new, mc$coord)

    p.loc <- dim(mc$loc.dsgn.mat)[2]
    p.scale <- dim(mc$scale.dsgn.mat)[2]
    p.shape <- dim(mc$shape.dsgn.mat)[2]

    Z.p <- matrix(0, S, n.impute)
      
    for(s in 1:S)
      {
        if(s%%1==0)print(s)
        ##--- First for the loc ------
        beta.mu <- mc$chain.loc[s,1:p.loc]
        mu.hat <- mc$loc.dsgn.mat %*% beta.mu
        resid.hat <- mc$chain.loc[s,(p.loc + 3 + 1):(p.loc + 3 + n.sta)] - mu.hat
        alpha <- mc$chain.loc[s,p.loc + 1]
        lambda <- mc$chain.loc[s,p.loc + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        C.inner.inv <- solve(C.inner)
        resid.impute.mean <- C.outer %*% C.inner.inv %*% resid.hat
        resid.impute.var <- alpha - apply(C.outer,1,"quad.form", C.inner.inv)
        resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
        mu.impute <- x.new.loc %*% beta.mu + resid.impute
        ##-------------------------------


        ##--- Now the Scale -------------
        beta <- mc$chain.scale[s,1:p.scale]
        sig.hat <- mc$scale.dsgn.mat %*% beta
        resid.hat <- mc$chain.scale[s,(p.scale + 3 + 1):(p.scale + 3 + n.sta)] - sig.hat
        alpha <- mc$chain.scale[s,p.scale + 1]
        lambda <- mc$chain.scale[s,p.scale + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        C.inner.inv <- solve(C.inner)
        resid.impute.mean <- C.outer %*% solve(C.inner) %*% resid.hat
        resid.impute.var <- alpha - apply(C.outer,1,"quad.form", C.inner.inv)
        resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
        sig.impute <- x.new.scale %*% beta + resid.impute
        ##------------------------------------

        ##--- Now the Shape -------------
        beta <- mc$chain.shape[s,1:p.shape]
        hat <- mc$shape.dsgn.mat %*% beta
        resid.hat <- mc$chain.shape[s,(p.shape + 3 + 1):(p.shape + 3 + n.sta)] - hat
        alpha <- mc$chain.shape[s,p.shape + 1]
        lambda <- mc$chain.shape[s,p.shape + 2]
        C.inner <- alpha * exp(-D.inner/lambda)
        diag(C.inner) <- diag(C.inner) + .000001 ##numerics
        C.outer <- alpha * exp(-D.outer/lambda)
        C.inner.inv <- solve(C.inner)
        resid.impute.mean <- C.outer %*% C.inner.inv %*% resid.hat
        resid.impute.var <- alpha - apply(C.outer,1,"quad.form", C.inner.inv)
        resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
        xi.impute <- x.new.shape %*% beta + resid.impute
        ##------------------------------------

        ##------ Get the Z.p -----------------
        Z.p[s,] <- z.p(p.return, mu.impute,sig.impute,xi.impute)
        ##------------------------------------
      }
    
    return(Z.p)

  }


impute.value.single <- function(s,mc, coord.new, x.new.loc, x.new.scale, x.new.shape,p.return)
  {
    ## AFL 5.8.13 This just does one iteration, for parallelization

    n.sta <- dim(mc$coord)[1]
    n.impute <- dim(coord.new)[1]

    D.inner <- make.D(mc$coord, mc$coord)
    D.outer <- make.D(coord.new, mc$coord)

    p.loc <- dim(mc$loc.dsgn.mat)[2]
    p.scale <- dim(mc$scale.dsgn.mat)[2]
    p.shape <- dim(mc$shape.dsgn.mat)[2]

    Z.p <- rep(0,  n.impute)
    resid.impute.var <- rep(0, n.impute)
    
    ##--- First for the loc ------
    beta.mu <- mc$chain.loc[s,1:p.loc]
    mu.hat <- mc$loc.dsgn.mat %*% beta.mu
    resid.hat <- mc$chain.loc[s,(p.loc + 3 + 1):(p.loc + 3 + n.sta)] - mu.hat
    alpha <- mc$chain.loc[s,p.loc + 1]
    lambda <- mc$chain.loc[s,p.loc + 2]
    C.inner <- alpha * exp(-D.inner/lambda)
    diag(C.inner) <- diag(C.inner) + .000001 ##numerics
    C.outer <- alpha * exp(-D.outer/lambda)
    C.inner.inv <- solve(C.inner)
    resid.impute.mean <- C.outer %*% C.inner.inv %*% resid.hat
    ## Amazingly, this next line is better behaved than apply
    for(i in 1:n.impute) resid.impute.var[i] <- alpha - C.outer[i,] %*% C.inner.inv %*% C.outer[i,]
    resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
    mu.impute <- x.new.loc %*% beta.mu + resid.impute
    ##-------------------------------


    ##--- Now the Scale -------------
    beta <- mc$chain.scale[s,1:p.scale]
    sig.hat <- mc$scale.dsgn.mat %*% beta
    resid.hat <- mc$chain.scale[s,(p.scale + 3 + 1):(p.scale + 3 + n.sta)] - sig.hat
    alpha <- mc$chain.scale[s,p.scale + 1]
    lambda <- mc$chain.scale[s,p.scale + 2]
    C.inner <- alpha * exp(-D.inner/lambda)
    diag(C.inner) <- diag(C.inner) + .000001 ##numerics
    C.outer <- alpha * exp(-D.outer/lambda)
    C.inner.inv <- solve(C.inner)
    resid.impute.mean <- C.outer %*% solve(C.inner) %*% resid.hat
    for(i in 1:n.impute) resid.impute.var[i] <- alpha - C.outer[i,] %*% C.inner.inv %*% C.outer[i,]
    resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
    sig.impute <- x.new.scale %*% beta + resid.impute
    ##------------------------------------

    ##--- Now the Shape -------------
    beta <- mc$chain.shape[s,1:p.shape]
    hat <- mc$shape.dsgn.mat %*% beta
    resid.hat <- mc$chain.shape[s,(p.shape + 3 + 1):(p.shape + 3 + n.sta)] - hat
    alpha <- mc$chain.shape[s,p.shape + 1]
    lambda <- mc$chain.shape[s,p.shape + 2]
    C.inner <- alpha * exp(-D.inner/lambda)
    diag(C.inner) <- diag(C.inner) + .000001 ##numerics
    C.outer <- alpha * exp(-D.outer/lambda)
    C.inner.inv <- solve(C.inner)
    resid.impute.mean <- C.outer %*% C.inner.inv %*% resid.hat
    for(i in 1:n.impute) resid.impute.var[i] <- alpha - C.outer[i,] %*% C.inner.inv %*% C.outer[i,]
    resid.impute <- rnorm(n.impute,resid.impute.mean, sd = sqrt(resid.impute.var))
    xi.impute <- x.new.shape %*% beta + resid.impute
    ##------------------------------------

    ##------ Get the Z.p -----------------
    Z.p <- z.p(p.return, mu.impute,sig.impute,xi.impute)
    ##------------------------------------
    print(paste("Finished", s))
    return(Z.p)
   #return(mu.impute)
  }

####################################################################
#Run script
library(parallel)
load("~/PhD/Sub-daily/Results/Alex_map/final/mc.mod6_10000.RData")
load("~/PhD/Sub-daily/Results/cov.mod6.RData")

print.figs <- FALSE

coord.new <- cov.mod6[,2:1]

N <- dim(coord.new)[1]

#mc$chain.loc <- mc$chain.loc[1:10,]
#mc$chain.scale <- mc$chain.scale[1:10,]
#mc$chain.shape <- mc$chain.shape[1:10,]

##Load up some covariates
x.new.loc <- matrix(1,N,1)
#x.new.loc <- cbind(x.new.loc,cov.mod6[,1])
x.new.loc <- cbind(x.new.loc,cov.mod6[,2:5])

x.new.scale <- matrix(1,N,1)
x.new.scale <- cbind(x.new.scale,cov.mod6[,3:5])

x.new.shape <- matrix(1,N,1)
##------ Finish making data -------------------------------

p.return <- .05 ## Let's look at the 20 year precipitation event
##Z <- impute.value(mc,coord.new, x.new.loc,x.new.scale,x.new.shape,p.return)
S <- dim(mc$chain.loc)[1]
cores.use <- 1

##########################################

l <- c()

for (s in 1:(S/10)) {
	l.mini <- mclapply(1:10, "impute.value.single",mc, coord.new, x.new.loc, x.new.scale, x.new.shape, p.return, mc.cores = cores.use, mc.silent = FALSE)

l <- c(l,unlist(l.mini))
rm(l.mini)
gc(reset=T)

}

#Z <- array(0, S, N)
#for(i in 1:S)
#  {
#    Z[i,] <- l[[i]]
#  }

qu <- c(0.025,0.5,0.975)
Q <- matrix(0,N,length(qu))
tt <- rep(0,S)

for (j in 1:N) {
	n<- 1
	for (i in seq(j,(N*S),by=N)) {
		tt[n] <- l[i]
		n <- n+1
	}
	Q[j,] <- quantile(tt,qu)
}

model <- "mod6"
rl <- 1/p.return

save(Q, file = paste("~/PhD/Sub-daily/Results/M",rl,model,"_10000_test2.RData",sep=""))
